---
layout: default
---

<div id="impress">
	<div id="start" class="step">
		<div class="slide">
			<div class="really_big">{</div><div class="big">Scope In JavaScript</div><div class="really_big">}</div>
		</div>
	</div>
	<div id="what_is_this" class="step" data-x="3000"> 
		<div class="slide">
			What is <span class="this">this</span>?
		</div>
	</div>
	<div id="what_is_this_cont" class="step" data-x="3000" data-y="3000">
		<div class="slide">
			<h2>What is <span class="this">this</span>?</h2>
			<ul>
				<li><span class="this">this</span> is a keyword and a special variable in JavaScript.</li>
				<li>It references an object called the "execution context" of the current scope.</li>
			</ul>
		</div>
	</div>
	<div id="global_this" class="step" data-x="6000" data-y="3000">
		<div class="slide">
			<h2><span class="this">this</span> in the global scope</h2>
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
console.log('What is this?:', this.toString());
{% endhighlight %}
			<ul><li>Output:</li></ul>
{% highlight bash %}
What is this?: [object Window]
{% endhighlight %}
			<ul><li>In the global scope, <span class="this">this</span> is always the window.</li></ul>
		</div>
	</div>
	<div id="function_this" class="step" data-x="9000" data-y="3000">
		<div class="slide">
			<h2><span class="this">this</span> in a function scope</h2>
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
function myFunc(){
  console.log('What is this?:', this.toString());
}
myFunc();
{% endhighlight %}
			<ul><li>Output:</li></ul>
{% highlight bash %}
What is this?: [object Window]
{% endhighlight %}
			<ul><li>In a function scope, <span class="this">this</span> is the window by default.</li></ul>
		</div>
	</div>
	<div id="event_handler_this" class="step" data-x="12000" data-y="3000">
		<div class="slide">
			<h2><span class="this">this</span> in an event handler</h2>
			<ul><li>HTML:</li></ul>
{% highlight javascript %}
<div id="my_div">Click Me!</div>
{% endhighlight %}
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
function myFunc(){
  console.log('What is this?:', this.toString());
}
document.getElementById('my_div').addEventListener('click', myFunc);
{% endhighlight %}
			<ul><li>Output on click:</li></ul>
{% highlight bash %}
What is this?: [object HTMLDivElement]
{% endhighlight %}
			<ul><li>In the scope of a function invoked as an event handler, <span class="this">this</span> is always the event target.</li></ul>
		</div>
	</div>
	<div id="method_this" class="step" data-x="15000" data-y="3000">
		<div class="slide">
			<h2><span class="this">this</span> in an object method</h2>
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
var myObj = {
  name : 'myObj',

  myMethod : function(){
    console.log('What is this?:', JSON.stringify(this));
  }
};

myObj.myMethod();
{% endhighlight %}
		<ul><li>Output:</li></ul>
{% highlight bash %}
What is this?: {"name":"myObj"}
{% endhighlight %}
			<ul><li>When a function is invoked as a property on an object, <span class="this">this</span> is always the object</li></ul>
		</div>
	</div>
	<div id="method_this_gotcha" class="step" data-x="18000" data-y="3000">
		<div class="slide">
			<h2>The dot is important</h2>
			<ul>
				<li>Even if the function is defined as a property, if it isn't called as a property, then <span class="this">this</span> will not be the object.</li>
			</ul>
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
var myObj = {
  name : 'myObj',

  myMethod : function(){ 
    console.log('What is this?:', this.toString());
  }
};

myOtherRef = myObj.myMethod();
myOtherRef();
{% endhighlight %}
			<ul><li>Output:</li></ul>
{% highlight bash %}
What is this?: [object Window]
{% endhighlight %}
			<ul><li>In this case because the function wasn't called as an object property, <span class="this">this</span> goes back to being the window.</li></ul>
		</div>
	</div>
	<div id="nested_this" class="step" data-x="21000" data-y="3000">
		<div class="slide">
			<h2><span class="this">this</span> in a nested function</h2>
			<ul><li>Lets say you have a function inside a function. Do they both have the same execution context?</li></ul>
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
var myObj = {
  myMethod : function(){ 
    function myNestedFunc(){
      console.log('What is this (nested)?:', this.toString());
    }
    console.log('What is this?:', this.toString());
    myNestedFunc();
  }
};

myObj.myMethod();
{% endhighlight %}
			<ul><li>Output:</li></ul>
{% highlight bash %}
What is this?: [object Object]
What is this (nested)?: [object Window]
{% endhighlight %}
			<ul><li>The answer is no. Each function has its own scope, and its own execution context.</li></ul>
		</div>
	</div>
	<div id="call_and_apply" class="step" data-x="24000" data-y="3000">
		<div class="slide">
			<h2>Specifying <span class="this">this</span> with call and apply</h2>
			<ul>
				<li>Functions have a default execution context when they are called the usual way.</li>
				<li>There is another way to call functions though, one where you can specify the context.</li>
				<li>Every function has two methods built in, call and apply.</li>
				<li>By invoking a function using these methods and passing an object, it is possible to specify an execution context.</li>
			</ul>
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
var myObj = {};

function myFunc(){
  console.log('What is this?:', this.toString());
}

myFunc();
myFunc.call(myObj);
myFunc.apply(myObj);
{% endhighlight %}
			<ul><li>Output:</li></ul>
{% highlight bash %}
What is this?: [object Window]
What is this?: [object Object]
What is this?: [object Object]
{% endhighlight %}
		</div>
	</div>
	<div id="uses_of_call_and_apply" class="step" data-x="27000" data-y="3000">
		<div class="slide">
			<h2>When to use call and apply</h2>
			<ul>
				<li>call and apply differ in the way that they accept arguments to be passed to the invoked function.
					<ul>
						<li>call passes along arguments after the context as they are passed.</li>
						<li>apply takes an array as a second argument, and passes the values in that array as arguments.</li>
					</ul>
				</li>
				<li>There are two main reasons to use call and apply. One is to change the execution context, the other is to preserve it.</li>
			</ul>
		</div>
	</div>
	<div id="practical_call_and_apply_2" class="step" data-x="30000" data-y="3000">
		<div class="slide">
			<h2>A practical use of call and apply</h2>
			<ul><li>Lets say you want to extend the regular console logging to prepend a date string.</li></ul>
			<ul><li>JavaScript:</li></ul>
{% highlight javascript %}
function myLogger(){
  // In every function scope there is a variable called arguments.
  // It contains all the arguments passed to the function.
  // arguments looks like an array, but it doesn't have any array methods.
  // We can use the array prototype methods on arguments by using call and apply
  Array.prototype.unshift.call(arguments, new Date().toDateString());
  // Now that we've added the date to arguments, we can apply them to console.log
  // We pass console as the first argument to preserve the context.
  console.log.apply(console, arguments);
}

myLogger('Wow, it works!');
{% endhighlight %}
			<ul><li>Output:</li></ul>
{% highlight bash %}
Wed Jun 04 2014 Wow, it works!
{% endhighlight %}
		</div>
	</div>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/impress.js/0.5.3/impress.js" type="text/javascript"></script>
<script type="text/javascript">impress().init();</script>
